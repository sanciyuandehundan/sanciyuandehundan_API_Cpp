// pch.cpp: 与预编译标头对应的源文件

#include "pch.h"
// 当使用预编译的头时，需要使用此源文件，编译才能成功。

Music::Music() {
	//midi_dll::handle = GlobalAlloc(GHND, size);//为缓冲区准备空间
	//midi_dll::midihdr.lpData = (LPSTR)GlobalLock(handle);//将缓冲区交予midihdr
	//midi_dll::midihdr.dwBufferLength = size;//将缓冲区大小与midihdr同步
	//midi_dll::midihdr.dwFlags = 0;//未知
};//建构函数


void Music::play_longmsg(int g[], HMIDIOUT handle) {
	MIDIHDR     midiHdr;
	HANDLE      hBuffer;
	UINT        err = 0;
	BYTE j[] = { 0x4d, 0x54, 0x68, 0x64, 0x00, 0x00, 0x00, 0x06, 0x00, 0x01, 0x00, 0x02, 0x01, 0xe0, 0x4d, 0x54, 0x72, 0x6b, 0x00, 0x00, 0x00, 0x19, 0x00, 0xff, 0x59, 0x02, 0x00, 0x00, 0x00, 0xff, 0x58, 0x04, 0x04, 0x02, 0x18, 0x08, 0x00, 0xff, 0x51, 0x03, 0x07, 0xa1, 0x20, 0x00, 0xff, 0x2f, 0x00, 0x4d, 0x54, 0x72, 0x6b, 0x00, 0x00, 0x00, 0x2c, 0x00, 0xc0, 0x00, 0x00, 0x90, 0x40, 0x5f, 0x83, 0x60, 0x80, 0x40, 0x00, 0x00, 0x90, 0x41, 0x5f, 0x83, 0x30, 0x80, 0x41, 0x00, 0x30, 0x90, 0x40, 0x5f, 0x83, 0x30, 0x80, 0x40, 0x00, 0x30, 0x90, 0x40, 0x5f, 0x83, 0x30, 0x80, 0x40, 0x00, 0x83, 0x60, 0xff, 0x2f, 0x00 };
	hBuffer = GlobalAlloc(GHND, sizeof(j));//分配缓冲区
	midiHdr.lpData = (LPSTR)GlobalLock(hBuffer);//将缓冲区交予midihdr
	midiHdr.dwBufferLength = sizeof(j);////将缓冲区大小与midihdr同步
	midiHdr.dwFlags = 0;//未知
	err = midiOutPrepareHeader(handle, &midiHdr, sizeof(midiHdr));//准备缓冲区和midiHdr
	memcpy(midiHdr.lpData, &j[0], sizeof(j));//将midi命令放入缓冲区
	//GlobalUnlock(hBuffer);
	//GlobalFree(hBuffer);
	//midiOutLongMsg(handle, &midiHdr, sizeof(midiHdr));//演奏
    
};

void Music::play_MCI(int pu[], HMIDIOUT handle) {
	/*
	LPCTSTR lpszCommand = (LPCTSTR)"open C:\\Users\\a0905\\Downloadsmid\\(13).mid";
	mciSendString((LPCTSTR)"play C:\\Users\\a0905\\Downloadsmid\\(13).mid" , 0, 0, 0);
	LPTSTR lpszReturnString;
	UINT cchReturn;
	HANDLE hwndCallback;
	//mciSendString(lpszCommand,lpszReturnString,cchReturn,hwndCallback);
	char buf[50];

	//mciSendString(lpszCommand,lpszReturnString, strlen(buf), NULL);
	*/

}

void Music::play_mid(HMIDIOUT handle) {
	HMIDISTRM	liu;
	MIDIHDR     midihdr;
	HANDLE      hBuffer;
	UINT        err = 0;
	BYTE j[] = { 0x4d, 0x54, 0x68, 0x64, 0x00, 0x00, 0x00, 0x06, 0x00, 0x01, 0x00, 0x02, 0x01, 0xe0, 0x4d, 0x54, 0x72, 0x6b, 0x00, 0x00, 0x00, 0x19, 0x00, 0xff, 0x59, 0x02, 0x00, 0x00, 0x00, 0xff, 0x58, 0x04, 0x04, 0x02, 0x18, 0x08, 0x00, 0xff, 0x51, 0x03, 0x07, 0xa1, 0x20, 0x00, 0xff, 0x2f, 0x00, 0x4d, 0x54, 0x72, 0x6b, 0x00, 0x00, 0x00, 0x2c, 0x00, 0xc0, 0x00, 0x00, 0x90, 0x40, 0x5f, 0x83, 0x60, 0x80, 0x40, 0x00, 0x00, 0x90, 0x41, 0x5f, 0x83, 0x30, 0x80, 0x41, 0x00, 0x30, 0x90, 0x40, 0x5f, 0x83, 0x30, 0x80, 0x40, 0x00, 0x30, 0x90, 0x40, 0x5f, 0x83, 0x30, 0x80, 0x40, 0x00, 0x83, 0x60, 0xff, 0x2f, 0x00 };
	hBuffer = GlobalAlloc(GHND, sizeof(j));//分配缓冲区
	midihdr.lpData = (LPSTR)GlobalLock(hBuffer);//将缓冲区交予midihdr
	midihdr.dwBufferLength = sizeof(j);////将缓冲区大小与midihdr同步
	midihdr.dwFlags = 0;//未知
	err = midiOutPrepareHeader(handle, &midihdr, sizeof(midihdr));//准备缓冲区和midiHdr
	memcpy(midihdr.lpData, &j[0], sizeof(j));//将midi命令放入缓冲区
	midiStreamOpen(&liu,0, 1, 0, 0, CALLBACK_NULL);
	midiStreamOut(liu, &midihdr, sizeof(MIDIHDR));
	//midiStreamClose(liu);
	//GlobalUnlock(hBuffer);
	//GlobalFree(hBuffer);
}

UINT Music::in_num() {
    return midiInGetNumDevs();
}

UINT Music::out_num() {
    return midiOutGetNumDevs();
}